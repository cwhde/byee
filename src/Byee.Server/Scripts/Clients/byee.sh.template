#!/bin/sh
# Byee Client - Auto-generated for {{BYEE_URL}}
# Version: {{BYEE_VERSION}}
# 
# Usage:
#   byee ./file.zip                     Send a file (encrypted)
#   byee ./myFolder                     Send a folder (zipped, encrypted)
#   byee --no-encrypt ./file.zip        Send without encryption
#   byee receive <id> <key>             Receive a file
#   byee --server <url> ./file.zip      Use different server temporarily
#   byee --update                       Update byee client
#   byee --uninstall                    Uninstall byee
#   byee --enable-folders               Enable folder support

BYEE_URL="{{BYEE_URL}}"
BYEE_VERSION="{{BYEE_VERSION}}"
BYEE_FOLDERS_ENABLED="false"
BYEE_SERVER_OVERRIDE=""

# Wordlist for passphrase generation (subset - full list on server)
# 4096 words from EFF wordlist, max 7 chars each
BYEE_WORDLIST='{{BYEE_WORDLIST}}'

# Colors
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    NC='\033[0m'
    BOLD='\033[1m'
else
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' NC='' BOLD=''
fi

info() { printf "${BLUE}[INFO]${NC} %s\n" "$1"; }
success() { printf "${GREEN}[OK]${NC} %s\n" "$1"; }
warn() { printf "${YELLOW}[WARN]${NC} %s\n" "$1"; }
error() { printf "${RED}[ERROR]${NC} %s\n" "$1" >&2; exit 1; }

# Format bytes to human readable
format_size() {
    bytes=$1
    # Handle empty or non-numeric input
    if [ -z "$bytes" ] || ! expr "$bytes" + 0 >/dev/null 2>&1; then
        printf "unknown size"
        return
    fi
    if [ "$bytes" -ge 1073741824 ] 2>/dev/null; then
        awk "BEGIN {printf \"%.2f GB\", $bytes / 1073741824}"
    elif [ "$bytes" -ge 1048576 ] 2>/dev/null; then
        awk "BEGIN {printf \"%.2f MB\", $bytes / 1048576}"
    elif [ "$bytes" -ge 1024 ] 2>/dev/null; then
        awk "BEGIN {printf \"%.2f KB\", $bytes / 1024}"
    else
        printf "%d B" "$bytes"
    fi
}

# Generate a random passphrase (4 words separated by hyphens)
generate_passphrase() {
    word_count=${1:-4}
    words=""
    
    # Count words in the wordlist
    total_words=$(echo "$BYEE_WORDLIST" | tr ',' '\n' | wc -l | tr -d ' ')
    
    for i in $(seq 1 $word_count); do
        # Generate random index using /dev/urandom
        if [ -r /dev/urandom ]; then
            rand=$(od -A n -t u4 -N 4 /dev/urandom | tr -d ' ')
            index=$((rand % total_words + 1))
        else
            # Fallback to awk's random (less secure but works everywhere)
            index=$(awk -v max="$total_words" 'BEGIN{srand(); print int(rand()*max)+1}')
        fi
        
        word=$(echo "$BYEE_WORDLIST" | tr ',' '\n' | sed -n "${index}p")
        
        if [ -z "$words" ]; then
            words="$word"
        else
            words="${words}-${word}"
        fi
    done
    
    echo "$words"
}

# Check basic dependencies
check_deps_basic() {
    for cmd in curl jq openssl; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            error "$cmd is required but not installed. Run the installer: curl -fsSL $BYEE_URL | sh"
        fi
    done
}

# Check encryption dependencies (openssl should always be available)
check_deps_encryption() {
    if ! command -v openssl >/dev/null 2>&1; then
        error "openssl is required for encryption but not found"
    fi
}

# Check folder/zip dependencies
check_deps_folders() {
    if ! command -v zip >/dev/null 2>&1 || ! command -v unzip >/dev/null 2>&1; then
        error "zip/unzip required for folder support. Run: byee --enable-folders"
    fi
}

# Get the effective server URL (with override support)
get_server_url() {
    if [ -n "$BYEE_SERVER_OVERRIDE" ]; then
        echo "$BYEE_SERVER_OVERRIDE"
    else
        echo "$BYEE_URL"
    fi
}

# Detect OS
detect_os() {
    case "$(uname -s)" in
        Linux*)
            if [ -f /etc/alpine-release ]; then
                echo "alpine"
            else
                echo "linux"
            fi
            ;;
        Darwin*)    echo "macos";;
        *)          echo "unknown";;
    esac
}

# Send a file
send_file() {
    file="$1"
    encrypt="$2"
    is_folder="false"
    
    # Check if it's a directory
    if [ -d "$file" ]; then
        if [ "$BYEE_FOLDERS_ENABLED" != "true" ]; then
            error "Folder support is not enabled. Run: byee --enable-folders"
        fi
        check_deps_folders
        is_folder="true"
    elif [ ! -f "$file" ]; then
        error "File or folder not found: $file"
    fi
    
    if [ "$is_folder" = "true" ]; then
        send_folder "$file" "$encrypt"
    else
        send_regular_file "$file" "$encrypt" "false"
    fi
}

# Get folder size in bytes (cross-platform)
get_folder_size() {
    folder="$1"
    # Try GNU du first (Linux)
    size=$(du -sb "$folder" 2>/dev/null | cut -f1)
    if [ -n "$size" ]; then
        echo "$size"
        return
    fi
    # macOS/BSD: du -sk gives kilobytes
    size=$(du -sk "$folder" 2>/dev/null | cut -f1)
    if [ -n "$size" ]; then
        echo $((size * 1024))
        return
    fi
    echo "0"
}

# Send a folder (zip and upload)
send_folder() {
    folder="$1"
    encrypt="$2"
    
    foldername=$(basename "$folder")
    # Get folder size
    foldersize=$(get_folder_size "$folder")
    foldersize_human=$(format_size "$foldersize")
    
    printf "${BLUE}[INFO]${NC} Preparing to send folder: ${BOLD}%s${NC} (%s)\n" "$foldername" "$foldersize_human"
    
    if [ "$encrypt" = "true" ]; then
        check_deps_encryption
        info "Zipping, encrypting and uploading..."
        send_folder_encrypted "$folder" "$foldername"
    else
        info "Zipping and uploading..."
        send_folder_raw "$folder" "$foldername"
    fi
}

# Send folder encrypted (pipe zip -> openssl -> curl)
send_folder_encrypted() {
    folder="$1"
    foldername="$2"
    server_url=$(get_server_url)
    
    # Generate passphrase (4 words)
    passphrase=$(generate_passphrase 4)
    
    if [ -z "$passphrase" ]; then
        error "Failed to generate encryption passphrase"
    fi
    
    info "Generated encryption key"
    
    # Get original folder size for header
    foldersize=$(get_folder_size "$folder")
    
    # Pipe: zip -> openssl enc -> curl (no temp files)
    cd "$(dirname "$folder")"
    response=$(zip -r -q - "$(basename "$folder")" | \
        openssl enc -aes-256-cbc -pbkdf2 -iter 100000 -pass "pass:${passphrase}" | \
        curl -s --fail -X POST "${server_url}/upload" \
            -H "Content-Type: application/octet-stream" \
            -H "X-Byee-Filename: ${foldername}.zip" \
            -H "X-Byee-Size: $foldersize" \
            -H "X-Byee-Encrypted: true" \
            -H "X-Byee-IsFolder: true" \
            --data-binary @- 2>&1)
    curl_exit=$?
    cd - >/dev/null
    
    if [ $curl_exit -ne 0 ]; then
        error "Upload failed: $response"
    fi
    
    file_id=$(echo "$response" | jq -r '.id // empty')
    
    if [ -z "$file_id" ]; then
        error "Failed to get file ID from server response: $response"
    fi
    
    printf "\n"
    printf "${GREEN}========================================${NC}\n"
    printf "${GREEN} Upload complete! (folder)${NC}\n"
    printf "${GREEN}========================================${NC}\n"
    printf "\n"
    printf "Share this command with the recipient:\n\n"
    printf "  ${CYAN}${BOLD}byee receive %s %s${NC}\n\n" "$file_id" "$passphrase"
    printf "${YELLOW}Note: This file can only be downloaded ONCE!${NC}\n"
}

# Send folder raw (pipe zip -> curl)
send_folder_raw() {
    folder="$1"
    foldername="$2"
    server_url=$(get_server_url)
    
    # Get original folder size for header
    foldersize=$(get_folder_size "$folder")
    
    # Pipe: zip -> curl (no temp files)
    cd "$(dirname "$folder")"
    response=$(zip -r -q - "$(basename "$folder")" | \
        curl -s --fail -X POST "${server_url}/upload" \
            -H "Content-Type: application/octet-stream" \
            -H "X-Byee-Filename: ${foldername}.zip" \
            -H "X-Byee-Size: $foldersize" \
            -H "X-Byee-Encrypted: false" \
            -H "X-Byee-IsFolder: true" \
            --data-binary @- 2>&1)
    curl_exit=$?
    cd - >/dev/null
    
    if [ $curl_exit -ne 0 ]; then
        error "Upload failed: $response"
    fi
    
    file_id=$(echo "$response" | jq -r '.id // empty')
    
    if [ -z "$file_id" ]; then
        error "Failed to get file ID from server response: $response"
    fi
    
    printf "\n"
    printf "${GREEN}========================================${NC}\n"
    printf "${GREEN} Upload complete! (folder)${NC}\n"
    printf "${GREEN}========================================${NC}\n"
    printf "\n"
    printf "Share this command with the recipient:\n\n"
    printf "  ${CYAN}${BOLD}byee receive %s${NC}\n\n" "$file_id"
    printf "${YELLOW}Note: This file can only be downloaded ONCE!${NC}\n"
}

# Send regular file
send_regular_file() {
    file="$1"
    encrypt="$2"
    is_folder="$3"
    
    filename=$(basename "$file")
    filesize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
    filesize_human=$(format_size "$filesize")
    
    if [ "$encrypt" = "true" ]; then
        printf "${BLUE}[INFO]${NC} Preparing to send (encrypted): ${BOLD}%s${NC} (%s)\n" "$filename" "$filesize_human"
        check_deps_encryption
        send_file_encrypted "$file" "$filename" "$filesize"
    else
        printf "${BLUE}[INFO]${NC} Preparing to send (unencrypted): ${BOLD}%s${NC} (%s)\n" "$filename" "$filesize_human"
        send_file_raw "$file" "$filename" "$filesize"
    fi
}

# Send file with encryption
send_file_encrypted() {
    file="$1"
    filename="$2"
    filesize="$3"
    server_url=$(get_server_url)
    
    # Generate passphrase (4 words)
    passphrase=$(generate_passphrase 4)
    
    if [ -z "$passphrase" ]; then
        error "Failed to generate encryption passphrase"
    fi
    
    info "Generated encryption key"
    info "Encrypting and uploading..."
    
    # Pipe: file -> openssl enc -> curl (no temp files)
    response=$(cat "$file" | \
        openssl enc -aes-256-cbc -pbkdf2 -iter 100000 -pass "pass:${passphrase}" | \
        curl -s --fail -X POST "${server_url}/upload" \
            -H "Content-Type: application/octet-stream" \
            -H "X-Byee-Filename: $filename" \
            -H "X-Byee-Size: $filesize" \
            -H "X-Byee-Encrypted: true" \
            --data-binary @- 2>&1)
    curl_exit=$?
    
    if [ $curl_exit -ne 0 ]; then
        error "Upload failed: $response"
    fi
    
    file_id=$(echo "$response" | jq -r '.id // empty')
    
    if [ -z "$file_id" ]; then
        error "Failed to get file ID from server response: $response"
    fi
    
    printf "\n"
    printf "${GREEN}========================================${NC}\n"
    printf "${GREEN} Upload complete!${NC}\n"
    printf "${GREEN}========================================${NC}\n"
    printf "\n"
    printf "Share this command with the recipient:\n\n"
    printf "  ${CYAN}${BOLD}byee receive %s %s${NC}\n\n" "$file_id" "$passphrase"
    printf "${YELLOW}Note: This file can only be downloaded ONCE!${NC}\n"
}

# Send file without encryption
send_file_raw() {
    file="$1"
    filename="$2"
    filesize="$3"
    server_url=$(get_server_url)
    
    info "Uploading..."
    
    response=$(curl -s --fail -X POST "${server_url}/upload" \
        -H "Content-Type: application/octet-stream" \
        -H "X-Byee-Filename: $filename" \
        -H "X-Byee-Size: $filesize" \
        -H "X-Byee-Encrypted: false" \
        --data-binary @"$file" 2>&1)
    curl_exit=$?
    
    if [ $curl_exit -ne 0 ]; then
        error "Upload failed: $response"
    fi
    
    file_id=$(echo "$response" | jq -r '.id // empty')
    
    if [ -z "$file_id" ]; then
        error "Failed to get file ID from server response: $response"
    fi
    
    printf "\n"
    printf "${GREEN}========================================${NC}\n"
    printf "${GREEN} Upload complete!${NC}\n"
    printf "${GREEN}========================================${NC}\n"
    printf "\n"
    printf "Share this command with the recipient:\n\n"
    printf "  ${CYAN}${BOLD}byee receive %s${NC}\n\n" "$file_id"
    printf "${YELLOW}Note: This file can only be downloaded ONCE!${NC}\n"
}

# Receive a file
receive_file() {
    file_id="$1"
    secret_key="$2"
    server_url=$(get_server_url)
    
    if [ -z "$file_id" ]; then
        error "Usage: byee receive <id> [key]"
    fi
    
    info "Requesting file info..."
    
    # Get file info and claim
    info_response=$(curl -s "${server_url}/download/${file_id}?info=true" -w "\n%{http_code}")
    http_code=$(echo "$info_response" | tail -n1)
    info_response=$(echo "$info_response" | sed '$d')
    
    if [ "$http_code" = "404" ]; then
        error "File not found or already downloaded"
    elif [ "$http_code" = "409" ]; then
        error "File already being downloaded by someone else"
    elif [ "$http_code" != "200" ]; then
        error "Failed to get file info (HTTP $http_code): $info_response"
    fi
    
    filename=$(echo "$info_response" | jq -r '.filename // "file"')
    filesize=$(echo "$info_response" | jq -r '.size // 0')
    filesize_human=$(echo "$info_response" | jq -r '.size_human // "unknown"')
    claim_token=$(echo "$info_response" | jq -r '.claim_token // empty')
    is_folder=$(echo "$info_response" | jq -r '.is_folder // false')
    
    if [ -z "$claim_token" ]; then
        error "Failed to claim file"
    fi
    
    is_encrypted="no"
    [ -n "$secret_key" ] && is_encrypted="yes"
    
    printf "\n"
    printf "${CYAN}========================================${NC}\n"
    printf "${CYAN} File: ${BOLD}%s${NC}\n" "$filename"
    printf "${CYAN} Size: %s${NC}\n" "$filesize_human"
    printf "${CYAN} Encrypted: %s${NC}\n" "$is_encrypted"
    if [ "$is_folder" = "true" ]; then
        printf "${CYAN} Type: Folder (zipped)${NC}\n"
    fi
    printf "${CYAN}========================================${NC}\n"
    printf "\n"
    
    # Confirmation prompt
    printf "Download this file? [y/N]: "
    read confirm
    
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        warn "Download cancelled. Note: The file is no longer available (it was claimed)."
        exit 0
    fi
    
    # Check if file already exists
    output_file="$filename"
    if [ -f "$output_file" ]; then
        printf "File '%s' already exists. Overwrite? [y/N]: " "$output_file"
        read overwrite
        if [ "$overwrite" != "y" ] && [ "$overwrite" != "Y" ]; then
            base="${filename%.*}"
            ext="${filename##*.}"
            counter=1
            while [ -f "$output_file" ]; do
                if [ "$base" = "$filename" ]; then
                    output_file="${base}_${counter}"
                else
                    output_file="${base}_${counter}.${ext}"
                fi
                counter=$((counter + 1))
            done
            info "Saving as: $output_file"
        fi
    fi
    
    # Download
    if [ -n "$secret_key" ]; then
        check_deps_encryption
        info "Downloading and decrypting..."
        
        tmp_encrypted=$(mktemp)
        
        # Download to temp file
        curl -s --fail -o "$tmp_encrypted" "${server_url}/download/${file_id}" \
            -H "X-Byee-Claim-Token: $claim_token"
        curl_exit=$?
        
        if [ $curl_exit -ne 0 ]; then
            rm -f "$tmp_encrypted"
            error "Download failed"
        fi
        
        # Decrypt with openssl
        if ! openssl enc -d -aes-256-cbc -pbkdf2 -iter 100000 -in "$tmp_encrypted" -out "$output_file" -pass "pass:${secret_key}"; then
            rm -f "$tmp_encrypted"
            error "Decryption failed - wrong key?"
        fi
        
        rm -f "$tmp_encrypted"
    else
        info "Downloading..."
        
        curl -s --fail -o "$output_file" "${server_url}/download/${file_id}" \
            -H "X-Byee-Claim-Token: $claim_token"
        curl_exit=$?
        
        if [ $curl_exit -ne 0 ]; then
            rm -f "$output_file"
            error "Download failed"
        fi
    fi
    
    # Verify file exists and has content
    if [ ! -f "$output_file" ] || [ ! -s "$output_file" ]; then
        rm -f "$output_file"
        error "Downloaded file is empty or missing"
    fi
    
    actual_size=$(stat -f%z "$output_file" 2>/dev/null || stat -c%s "$output_file" 2>/dev/null || echo 0)
    actual_size_human=$(format_size "$actual_size")
    
    # Handle folder extraction
    if [ "$is_folder" = "true" ]; then
        if [ "$BYEE_FOLDERS_ENABLED" = "true" ] && command -v unzip >/dev/null 2>&1; then
            # Auto-extract when folder support is enabled
            info "Extracting folder archive..."
            unzip -q -o "$output_file"
            rm -f "$output_file"
            
            # Get folder name (filename without .zip) for display
            folder_name="${output_file%.zip}"
            if [ "$folder_name" = "$output_file" ]; then
                folder_name="extracted files"
            fi
            
            printf "\n"
            printf "${GREEN}========================================${NC}\n"
            printf "${GREEN} Download & Extract complete!${NC}\n"
            printf "${GREEN}========================================${NC}\n"
            printf "\n"
            printf "Extracted: ${BOLD}%s${NC}\n" "$folder_name"
            return
        else
            # Folder support not enabled - warn and download as zip
            printf "\n"
            warn "This file was uploaded as a folder."
            warn "Your client doesn't have folder support enabled."
            printf "${YELLOW}[WARN]${NC} To enable: ${CYAN}byee --enable-folders${NC}\n"
            printf "\n"
            printf "Downloading as zip archive instead...\n"
        fi
    fi
    
    printf "\n"
    printf "${GREEN}========================================${NC}\n"
    printf "${GREEN} Download complete!${NC}\n"
    printf "${GREEN}========================================${NC}\n"
    printf "\n"
    printf "Saved: ${BOLD}%s${NC} (%s)\n" "$output_file" "$actual_size_human"
}

# Run update
do_update() {
    local os=$(detect_os)
    info "Fetching update script..."
    curl -fsSL "${BYEE_URL}/update/${os}" | sh
}

# Run uninstall
do_uninstall() {
    local os=$(detect_os)
    local args="$1"
    
    info "Fetching uninstall script..."
    if [ -n "$args" ]; then
        curl -fsSL "${BYEE_URL}/uninstall/${os}" | sh -s -- $args
    else
        curl -fsSL "${BYEE_URL}/uninstall/${os}" | sh
    fi
}

# Enable folder support
do_enable_folders() {
    if [ "$BYEE_FOLDERS_ENABLED" = "true" ]; then
        success "Folder support is already enabled!"
        exit 0
    fi
    
    local os=$(detect_os)
    info "Fetching enable-folders script..."
    curl -fsSL "${BYEE_URL}/enable-folders/${os}" | sh
}

# Show usage
usage() {
    printf "Byee - One-time file transfer\n"
    printf "Server: %s\n" "$BYEE_URL"
    printf "Version: %s\n"
    printf "Folders: %s\n\n" "$BYEE_FOLDERS_ENABLED"
    printf "Usage:\n"
    printf "  byee <file>                       Send a file (encrypted by default)\n"
    printf "  byee <folder>                     Send a folder (if folder support enabled)\n"
    printf "  byee --no-encrypt <file>          Send without encryption\n"
    printf "  byee receive <id> [key]           Receive a file\n"
    printf "  byee --server <url> <file>        Use different server temporarily\n"
    printf "  byee --server <url> receive ...   Receive from different server\n"
    printf "\n"
    printf "Management:\n"
    printf "  byee --update                     Update byee client\n"
    printf "  byee --uninstall                  Interactive uninstall\n"
    printf "  byee --uninstall all              Uninstall everything\n"
    printf "  byee --uninstall --deps age,jq    Uninstall client + specified deps\n"
    printf "  byee --enable-folders             Enable folder support\n"
    printf "\n"
    printf "Options:\n"
    printf "  byee --help                       Show this help\n"
    printf "  byee --version                    Show version\n"
}

# Main
main() {
    check_deps_basic
    
    # Parse --server option first (can appear anywhere before command)
    while [ $# -gt 0 ]; do
        case "$1" in
            --server|-s)
                shift
                if [ -z "$1" ]; then
                    error "Missing server URL after --server"
                fi
                BYEE_SERVER_OVERRIDE="$1"
                shift
                ;;
            *)
                break
                ;;
        esac
    done
    
    case "${1:-}" in
        ""|--help|-h)
            usage
            ;;
        --version|-v)
            echo "byee $BYEE_VERSION"
            echo "Server: $BYEE_URL"
            echo "Folders enabled: $BYEE_FOLDERS_ENABLED"
            ;;
        --update)
            do_update
            ;;
        --uninstall)
            shift
            do_uninstall "$*"
            ;;
        --enable-folders)
            do_enable_folders
            ;;
        receive|recv|r)
            shift
            receive_file "$@"
            ;;
        --no-encrypt|-n)
            shift
            send_file "$1" "false"
            ;;
        *)
            send_file "$1" "true"
            ;;
    esac
}

main "$@"
