#!/bin/sh
# Byee Client - Auto-generated for {{BYEE_URL}}
# Version: {{BYEE_VERSION}}
# 
# Usage:
#   byee ./file.zip                     Send a file (encrypted)
#   byee --no-encrypt ./file.zip        Send without encryption
#   byee receive <id> [key]             Receive a file

set -e

BYEE_URL="{{BYEE_URL}}"
BYEE_VERSION="{{BYEE_VERSION}}"

# Colors
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    NC='\033[0m'
    BOLD='\033[1m'
else
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' NC='' BOLD=''
fi

info() { printf "${BLUE}[INFO]${NC} %s\n" "$1"; }
success() { printf "${GREEN}[OK]${NC} %s\n" "$1"; }
warn() { printf "${YELLOW}[WARN]${NC} %s\n" "$1"; }
error() { printf "${RED}[ERROR]${NC} %s\n" "$1" >&2; exit 1; }

# Format bytes to human readable (using awk for POSIX compatibility)
format_size() {
    local bytes=$1
    if [ "$bytes" -ge 1073741824 ]; then
        awk "BEGIN {printf \"%.2f GB\", $bytes / 1073741824}"
    elif [ "$bytes" -ge 1048576 ]; then
        awk "BEGIN {printf \"%.2f MB\", $bytes / 1048576}"
    elif [ "$bytes" -ge 1024 ]; then
        awk "BEGIN {printf \"%.2f KB\", $bytes / 1024}"
    else
        printf "%d B" "$bytes"
    fi
}

# Shorten the age secret key for display (remove AGE-SECRET-KEY- prefix)
shorten_key() {
    echo "$1" | sed 's/^AGE-SECRET-KEY-//'
}

# Expand shortened key back to full format
expand_key() {
    local key="$1"
    if echo "$key" | grep -q "^AGE-SECRET-KEY-"; then
        echo "$key"
    else
        echo "AGE-SECRET-KEY-$key"
    fi
}

# Check dependencies (encryption-related deps only checked when needed)
check_deps_basic() {
    for cmd in curl jq; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            error "$cmd is required but not installed. Run the installer: curl -fsSL $BYEE_URL | sh"
        fi
    done
}

check_deps_encryption() {
    if ! command -v age >/dev/null 2>&1; then
        error "age is required for encryption. Run the installer: curl -fsSL $BYEE_URL | sh"
    fi
}

# Send a file (with optional encryption)
send_file() {
    local file="$1"
    local encrypt="$2"  # "true" or "false"
    
    if [ ! -f "$file" ]; then
        error "File not found: $file"
    fi
    
    local filename=$(basename "$file")
    local filesize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
    local filesize_human=$(format_size "$filesize")
    
    if [ "$encrypt" = "true" ]; then
        info "Preparing to send (encrypted): ${BOLD}$filename${NC} ($filesize_human)"
        check_deps_encryption
        send_file_encrypted "$file" "$filename" "$filesize"
    else
        info "Preparing to send (unencrypted): ${BOLD}$filename${NC} ($filesize_human)"
        send_file_raw "$file" "$filename" "$filesize"
    fi
}

# Send file with encryption
send_file_encrypted() {
    local file="$1"
    local filename="$2"
    local filesize="$3"
    
    # Generate age key pair for this transfer
    local tmp_key=$(mktemp)
    local pubkey
    
    age-keygen -o "$tmp_key" 2>/dev/null
    pubkey=$(grep "public key:" "$tmp_key" | cut -d: -f2 | tr -d ' ')
    local secret_key=$(grep "AGE-SECRET-KEY" "$tmp_key")
    local short_key=$(shorten_key "$secret_key")
    
    info "Generated encryption key"
    
    # Stream: file -> age encrypt -> pv (progress) -> curl -> server
    info "Encrypting and uploading..."
    
    local response
    local http_code
    
    if command -v pv >/dev/null 2>&1; then
        # With progress bar using pv
        response=$(pv -s "$filesize" -N "Encrypting & Uploading" -f "$file" 2>/dev/tty | \
            age -r "$pubkey" | \
            curl -sf -X POST "${BYEE_URL}/upload" \
                -H "Content-Type: application/octet-stream" \
                -H "X-Byee-Filename: $filename" \
                -H "X-Byee-Size: $filesize" \
                -H "X-Byee-Encrypted: true" \
                -H "Transfer-Encoding: chunked" \
                --data-binary @- \
                -w "\n%{http_code}")
    else
        # Without progress bar
        info "Uploading (install pv for progress bar)..."
        response=$(cat "$file" | \
            age -r "$pubkey" | \
            curl -sf -X POST "${BYEE_URL}/upload" \
                -H "Content-Type: application/octet-stream" \
                -H "X-Byee-Filename: $filename" \
                -H "X-Byee-Size: $filesize" \
                -H "X-Byee-Encrypted: true" \
                -H "Transfer-Encoding: chunked" \
                --data-binary @- \
                -w "\n%{http_code}")
    fi
    
    # Parse response
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')
    
    if [ "$http_code" != "200" ]; then
        rm -f "$tmp_key"
        error "Upload failed (HTTP $http_code): $response"
    fi
    
    local file_id=$(echo "$response" | jq -r '.id // empty')
    
    if [ -z "$file_id" ]; then
        rm -f "$tmp_key"
        error "Failed to get file ID from server response"
    fi
    
    # Clean up key file
    rm -f "$tmp_key"
    
    printf "\n"
    printf "${GREEN}╔════════════════════════════════════════════════════════════╗${NC}\n"
    printf "${GREEN}║${NC} ${BOLD}Upload complete!${NC}                                           ${GREEN}║${NC}\n"
    printf "${GREEN}╚════════════════════════════════════════════════════════════╝${NC}\n"
    printf "\n"
    printf "Share this command with the recipient:\n\n"
    printf "  ${CYAN}${BOLD}byee receive %s %s${NC}\n\n" "$file_id" "$short_key"
    printf "${YELLOW}Note: This file can only be downloaded ONCE!${NC}\n"
}

# Send file without encryption
send_file_raw() {
    local file="$1"
    local filename="$2"
    local filesize="$3"
    
    info "Uploading..."
    
    local response
    local http_code
    
    if command -v pv >/dev/null 2>&1; then
        response=$(pv -s "$filesize" -N "Uploading" -f "$file" 2>/dev/tty | \
            curl -sf -X POST "${BYEE_URL}/upload" \
                -H "Content-Type: application/octet-stream" \
                -H "X-Byee-Filename: $filename" \
                -H "X-Byee-Size: $filesize" \
                -H "X-Byee-Encrypted: false" \
                -H "Transfer-Encoding: chunked" \
                --data-binary @- \
                -w "\n%{http_code}")
    else
        info "Uploading (install pv for progress bar)..."
        response=$(cat "$file" | \
            curl -sf -X POST "${BYEE_URL}/upload" \
                -H "Content-Type: application/octet-stream" \
                -H "X-Byee-Filename: $filename" \
                -H "X-Byee-Size: $filesize" \
                -H "X-Byee-Encrypted: false" \
                -H "Transfer-Encoding: chunked" \
                --data-binary @- \
                -w "\n%{http_code}")
    fi
    
    # Parse response
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')
    
    if [ "$http_code" != "200" ]; then
        error "Upload failed (HTTP $http_code): $response"
    fi
    
    local file_id=$(echo "$response" | jq -r '.id // empty')
    
    if [ -z "$file_id" ]; then
        error "Failed to get file ID from server response"
    fi
    
    printf "\n"
    printf "${GREEN}╔════════════════════════════════════════════════════════════╗${NC}\n"
    printf "${GREEN}║${NC} ${BOLD}Upload complete!${NC}                                           ${GREEN}║${NC}\n"
    printf "${GREEN}╚════════════════════════════════════════════════════════════╝${NC}\n"
    printf "\n"
    printf "Share this command with the recipient:\n\n"
    printf "  ${CYAN}${BOLD}byee receive %s${NC}\n\n" "$file_id"
    printf "${YELLOW}Note: This file can only be downloaded ONCE!${NC}\n"
}

# Receive a file
receive_file() {
    local file_id="$1"
    local secret_key="$2"
    
    if [ -z "$file_id" ]; then
        error "Usage: byee receive <id> [key]"
    fi
    
    info "Requesting file info..."
    
    # First request: get info and claim the file
    local info_response
    local http_code
    
    info_response=$(curl -s "${BYEE_URL}/download/${file_id}?info=true" -w "\n%{http_code}")
    http_code=$(echo "$info_response" | tail -n1)
    info_response=$(echo "$info_response" | sed '$d')
    
    if [ "$http_code" = "404" ]; then
        error "File not found or already downloaded"
    elif [ "$http_code" = "409" ]; then
        error "File already being downloaded by someone else"
    elif [ "$http_code" != "200" ]; then
        error "Failed to get file info (HTTP $http_code): $info_response"
    fi
    
    local filename=$(echo "$info_response" | jq -r '.filename // "file"')
    local filesize=$(echo "$info_response" | jq -r '.size // 0')
    local filesize_human=$(echo "$info_response" | jq -r '.size_human // "unknown"')
    local claim_token=$(echo "$info_response" | jq -r '.claim_token // empty')
    
    if [ -z "$claim_token" ]; then
        error "Failed to claim file"
    fi
    
    printf "\n"
    printf "${CYAN}╔════════════════════════════════════════════════════════════╗${NC}\n"
    printf "${CYAN}║${NC} File: ${BOLD}%-50s${NC} ${CYAN}║${NC}\n" "$filename"
    printf "${CYAN}║${NC} Size: %-52s ${CYAN}║${NC}\n" "$filesize_human"
    if [ -n "$secret_key" ]; then
        printf "${CYAN}║${NC} Encrypted: Yes                                             ${CYAN}║${NC}\n"
    else
        printf "${CYAN}║${NC} Encrypted: No                                              ${CYAN}║${NC}\n"
    fi
    printf "${CYAN}╚════════════════════════════════════════════════════════════╝${NC}\n"
    printf "\n"
    
    # Confirmation prompt
    printf "Download this file? [y/N]: "
    read -r confirm
    
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        warn "Download cancelled. Note: The file is no longer available (it was claimed)."
        exit 0
    fi
    
    # Check if file already exists
    local output_file="$filename"
    if [ -f "$output_file" ]; then
        printf "File '$output_file' already exists. Overwrite? [y/N]: "
        read -r overwrite
        if [ "$overwrite" != "y" ] && [ "$overwrite" != "Y" ]; then
            # Generate unique name
            local base="${filename%.*}"
            local ext="${filename##*.}"
            local counter=1
            while [ -f "$output_file" ]; do
                if [ "$base" = "$filename" ]; then
                    output_file="${base}_${counter}"
                else
                    output_file="${base}_${counter}.${ext}"
                fi
                counter=$((counter + 1))
            done
            info "Saving as: $output_file"
        fi
    fi
    
    # Download with or without decryption
    if [ -n "$secret_key" ]; then
        check_deps_encryption
        info "Downloading and decrypting..."
        
        # Expand key if shortened
        local full_key=$(expand_key "$secret_key")
        
        # Create temp file for secret key (age needs file input for identity)
        local tmp_key=$(mktemp)
        echo "$full_key" > "$tmp_key"
        
        # Stream: server -> curl -> pv (progress) -> age decrypt -> file
        if command -v pv >/dev/null 2>&1; then
            curl -sf "${BYEE_URL}/download/${file_id}" \
                -H "X-Byee-Claim-Token: $claim_token" | \
                pv -s "$filesize" -N "Downloading & Decrypting" -f 2>/dev/tty | \
                age -d -i "$tmp_key" > "$output_file"
        else
            info "Downloading (install pv for progress bar)..."
            curl -sf "${BYEE_URL}/download/${file_id}" \
                -H "X-Byee-Claim-Token: $claim_token" | \
                age -d -i "$tmp_key" > "$output_file"
        fi
        
        local exit_code=$?
        rm -f "$tmp_key"
    else
        info "Downloading..."
        
        # Stream: server -> curl -> pv (progress) -> file
        if command -v pv >/dev/null 2>&1; then
            curl -sf "${BYEE_URL}/download/${file_id}" \
                -H "X-Byee-Claim-Token: $claim_token" | \
                pv -s "$filesize" -N "Downloading" -f 2>/dev/tty > "$output_file"
        else
            info "Downloading (install pv for progress bar)..."
            curl -sf "${BYEE_URL}/download/${file_id}" \
                -H "X-Byee-Claim-Token: $claim_token" -o "$output_file"
        fi
        
        local exit_code=$?
    fi
    
    if [ $exit_code -ne 0 ]; then
        rm -f "$output_file"
        error "Download or decryption failed"
    fi
    
    # Verify file was created
    if [ ! -f "$output_file" ] || [ ! -s "$output_file" ]; then
        rm -f "$output_file"
        error "Downloaded file is empty or missing"
    fi
    
    local actual_size=$(stat -f%z "$output_file" 2>/dev/null || stat -c%s "$output_file" 2>/dev/null)
    local actual_size_human=$(format_size "$actual_size")
    
    printf "\n"
    printf "${GREEN}╔════════════════════════════════════════════════════════════╗${NC}\n"
    printf "${GREEN}║${NC} ${BOLD}Download complete!${NC}                                         ${GREEN}║${NC}\n"
    printf "${GREEN}╚════════════════════════════════════════════════════════════╝${NC}\n"
    printf "\n"
    printf "Saved: ${BOLD}%s${NC} (%s)\n" "$output_file" "$actual_size_human"
}

# Show usage
usage() {
    printf "Byee - One-time file transfer\n"
    printf "Server: %s\n" "$BYEE_URL"
    printf "Version: %s\n\n" "$BYEE_VERSION"
    printf "Usage:\n"
    printf "  byee <file>                     Send a file (encrypted by default)\n"
    printf "  byee --no-encrypt <file>        Send a file without encryption\n"
    printf "  byee receive <id> [key]         Receive a file\n"
    printf "  byee --help                     Show this help\n"
    printf "  byee --version                  Show version\n"
}

# Main
main() {
    check_deps_basic
    
    case "${1:-}" in
        ""|--help|-h)
            usage
            ;;
        --version|-v)
            echo "byee $BYEE_VERSION"
            echo "Server: $BYEE_URL"
            ;;
        receive|recv|r)
            shift
            receive_file "$@"
            ;;
        --no-encrypt|-n)
            shift
            send_file "$1" "false"
            ;;
        *)
            # Assume it's a file to send (encrypted by default)
            send_file "$1" "true"
            ;;
    esac
}

main "$@"
